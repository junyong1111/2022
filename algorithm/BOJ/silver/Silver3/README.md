- 1.백준(1003) 피보나치 함수
    #### 위 문제는 단순히 0과1이 나온 횟수를 구하는 문제가 아닌 메모제이션을 이용하여 반복적인 계산을 피해 시간초과가 나지않게 하는것이 주 목적이다.
    - 피보나치 함수를 재귀적으로 사용하지만 동일한 계산을 할 때 효율적인 메모제이션 방식을 이용하여 이미 계산된 피보나치 수열의 값을 저장하는 방식으로 시간초과 해결
    - 0이 나온횟수와 1이 나온횟수의 패턴을 분석한 결과 
        - 1이 나온횟수 = fib(n)의 값과 동일
        - 0이 나온횟수 = fib(n-1)의 값과 동일
        위와 같은 패턴이 나온다는걸 확인 

- 2.백준(1929) 소수 구하기
    #### 일반적인 소수를 구하는 방법이 아닌 에라토스테네스의 체를 이용하는 방법으로 푸는 문제이다
    - i = 2 ~ i*i<N 까지 반복문을 돌린다 그 이유는 어차피 배수이기때문에 원하는 의 루트값까지만 가도 이미 모든 소수는 구해진다
    - j = 2*i ~ j<=N 까지 j=j+i 즉 주어진값의 배수만큼 반복을 돌아준다
    - 미리 선언했던 배열의 모든 값을 0으로 바꾼 후 만약 현재 값이 제거 되지않았다면 그 배수부터 제거 하는 방식으로 처리한다
    - 에라토스테네스의 체는 소수를 한번에 찾거나 개수 등을 찾을 때 유용하다 

- 3.백준(1463) 1로 만들기
    #### 다이나믹 프로그래밍을 이용하여 푸는 문제이다. 한 번 계산된 값을 테이블에 저장하야 재연산하는 과정을 피하는 방법이다. 만약 배열의 값이 저장되어있지 않다면 새롭게 갱신한다.
    - 3으로 나뉘어지면서 2로 나뉘어지는경우 
        - 3으로 나뉘어진 값과 2로 나뉘어진 값 중 최소값을 찾는다
        - 그 최소값과 N-1을 한 값중 최솟값을 찾아 그 값을 배열의 갱신해준다. 이 과정이 필요한가 ?
    - 3으로만 나뉘어지는경우 
        - 3으로 나뉘어진 값과 N-1을 한 값중 최솟값을 찾아 그 값을 배열의 갱신해준다.
    - 2으로 나눠지는 경우 
        - 2로 나뉘어진 값과 N-1값 중 최솟값을 찾아 그 값을 배열의 갱신
    - 둘 다 아닌경우
        - N-1의 값을 배열의 갱신