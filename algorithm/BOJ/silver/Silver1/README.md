- 1.백준(2178) 미로탐색
  ####  너비우선탐색(BFS)를 이용하여 최단거리를 탐색하는 문제이다..
  ##### <u> 가중치가 없는 그래프에서는 BFS를 이용하면 최단거리를 탐색할 수 있다.</u>
  1. 문제에서 주어진 조건에 맞게 지도(Map)을 생성
     - 0은 벽이며 1은 지날 수 있는 길이다.
  2. 각 좌표마다의 최단거리를 저장할 거리 배열을 생성
    - 이동이 가능할 경우 이전 좌표에서 +1을 해주는식으로 이동한다.
  3. 최초 0,0을 Queue에 넣어주면서 시작한다.

- 큐의 원소가 있다면 반복실행
  1. 현재 Queue의 저장된 좌표를 빼고 pop()
  2. 미로를 대각선으로 갈 수없으므로 4방향만 체크
     - 현재 좌표에서 4방향으로 갈 수있고 그 좌표가 이동가능한 좌표라면 즉 벽이 아니라면
     - 새로운 좌표를 Queue에 삽입
     - 새로운 좌표의 재방문을 피하기 위해 0으로 갱신
     - 거리 좌표를 이전 값 +1 로 갱신
  3. 만약 Distance 배열의 [N-1][M-1] 값이 0이라면 탐색이 실패한 경우고 값이 저장되어있다면 그 값이 최단거리이다 


- 2.백준(2667) 단지붙이기
  ####  너비우선탐색(BFS) 또는 깊이우선탐색(DFS)를 이용하여 단지의 개수를 구하는 문제이다
  ##### <u> DFS로 한번에 구하는게 아니라 for문을 통해서 구할 수 있다.</u>
  1. 문제에서 주어진 조건에 맞게 지도(Map)을 생성
     - 0은 빈 집이며 1은 집이다.
  2. 좌표 구조체 생성
  3. 단지마다 숫자를 저장 할 구조체와 배열 생성
  4. 반복문을 이용하여 맵의 전체를 돌아다니면서 집이 있는 곳에서 DFS 실행하고 단지의 갯수를 반환 후 배열의 저장
  5. 조건에 맞게 오름차순으로 정렬

- 스택의 원소가 있다면 반복
  1. 현재 Stack의 저장된 좌표를 빼고 pop()하고 숫자를 1증가
  2. 미로를 대각선으로 갈 수없으므로 4방향만 체크
     - 현재 좌표에서 4방향으로 갈 수있고 그 좌표가 이동가능한 좌표라면 즉 비어있지 않다면
     - 새로운 좌표를 Stack에 삽입
     - 새로운 좌표의 재방문을 피하기 위해 0으로 갱신
     - DFS수행


- 3.백준(1697) 숨바꼭질
  ####  너비우선탐색(BFS)을 이용하여 최단 경로를 찾는 문제이다
  ##### <u> BFS를 이용하여 주어진 조건에 맞게 탐새하고 종료조건만 추가해주면 쉽게 해결이 가능했다. </u>
  1. 조건에 맞게 최대사이즈 배열을 생성
  2. 앞,뒤 그리고 2배 보폭으로 최단거리 탐색
  3. 원하는 목적지까지 최단거리 탐색이 끝나면 Flag를 바꿔서 바로 종료
  4. 최초 시작점을 1로 설정했으므로 정답은 -1을 해준다.

- 큐의 원소가 있다면 반복
  1. 현재 큐의 저장된 좌표를 빼고 pop()
  2. 앞뒤, 그리고 2배 보폭으로 탐색 (3방향)
     - 현재 좌표에서 3방향으로 갈 수있고 탐색이 이루어지지 않았다면
     - 새로운 좌표를 Queue 삽입
     - BFS수행
