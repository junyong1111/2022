- 1.백준(2178) 미로탐색
  ####  너비우선탐색(BFS)를 이용하여 최단거리를 탐색하는 문제이다..
  ##### <u> 가중치가 없는 그래프에서는 BFS를 이용하면 최단거리를 탐색할 수 있다.</u>
  1. 문제에서 주어진 조건에 맞게 지도(Map)을 생성
     - 0은 벽이며 1은 지날 수 있는 길이다.
  2. 각 좌표마다의 최단거리를 저장할 거리 배열을 생성
    - 이동이 가능할 경우 이전 좌표에서 +1을 해주는식으로 이동한다.
  3. 최초 0,0을 Queue에 넣어주면서 시작한다.

- 큐의 원소가 있다면 반복실행
  1. 현재 Queue의 저장된 좌표를 빼고 pop()
  2. 미로를 대각선으로 갈 수없으므로 4방향만 체크
     - 현재 좌표에서 4방향으로 갈 수있고 그 좌표가 이동가능한 좌표라면 즉 벽이 아니라면
     - 새로운 좌표를 Queue에 삽입
     - 새로운 좌표의 재방문을 피하기 위해 0으로 갱신
     - 거리 좌표를 이전 값 +1 로 갱신
  3. 만약 Distance 배열의 [N-1][M-1] 값이 0이라면 탐색이 실패한 경우고 값이 저장되어있다면 그 값이 최단거리이다 


- 2.백준(2667) 단지붙이기
  ####  너비우선탐색(BFS) 또는 깊이우선탐색(DFS)를 이용하여 단지의 개수를 구하는 문제이다
  ##### <u> DFS로 한번에 구하는게 아니라 for문을 통해서 구할 수 있다.</u>
  1. 문제에서 주어진 조건에 맞게 지도(Map)을 생성
     - 0은 빈 집이며 1은 집이다.
  2. 좌표 구조체 생성
  3. 단지마다 숫자를 저장 할 구조체와 배열 생성
  4. 반복문을 이용하여 맵의 전체를 돌아다니면서 집이 있는 곳에서 DFS 실행하고 단지의 갯수를 반환 후 배열의 저장
  5. 조건에 맞게 오름차순으로 정렬

- 스택의 원소가 있다면 반복
  1. 현재 Stack의 저장된 좌표를 빼고 pop()하고 숫자를 1증가
  2. 미로를 대각선으로 갈 수없으므로 4방향만 체크
     - 현재 좌표에서 4방향으로 갈 수있고 그 좌표가 이동가능한 좌표라면 즉 비어있지 않다면
     - 새로운 좌표를 Stack에 삽입
     - 새로운 좌표의 재방문을 피하기 위해 0으로 갱신
     - DFS수행


- 3.백준(1697) 숨바꼭질
  ####  너비우선탐색(BFS)을 이용하여 최단 경로를 찾는 문제이다
  ##### <u> BFS를 이용하여 주어진 조건에 맞게 탐새하고 종료조건만 추가해주면 쉽게 해결이 가능했다. </u>
  1. 조건에 맞게 최대사이즈 배열을 생성
  2. 앞,뒤 그리고 2배 보폭으로 최단거리 탐색
  3. 원하는 목적지까지 최단거리 탐색이 끝나면 Flag를 바꿔서 바로 종료
  4. 최초 시작점을 1로 설정했으므로 정답은 -1을 해준다.

- 큐의 원소가 있다면 반복
  1. 현재 큐의 저장된 좌표를 빼고 pop()
  2. 앞뒤, 그리고 2배 보폭으로 탐색 (3방향)
     - 현재 좌표에서 3방향으로 갈 수있고 탐색이 이루어지지 않았다면
     - 새로운 좌표를 Queue 삽입
     - BFS수행


- 4.백준(1931) 회의실 배정
  ####  그리디 알고리즘을 이용하여 푸는 문제이다 정렬만 잘 사용한다면 어렵지는 않다.
  ##### <u> sort를 정의함에 있어서 종료시간이 같을 때 정렬기준을 else if로 하면 segment falut에러가 뜬다.. </u>
  
  1. 주어진 조건에 맞게 구조체를 선언
  2. 반복문을 둘면서 구조체 벡터에 주어진 시작과 종료시간을 삽입
  3. 종료시간을 기준으로 정렬 -> 종료시간이 같다면 시작시간을 기준으로 정렬
  4. 반복문을 통해서 제일 빠른 순서부터 내려오면 된다.


- 5.백준(13335) 트럭
####  큐를 이용하여 구현하는 문제이며 대기 트럭이 다리에 오르지 못했을 경우 처리방법을 생각하기 어려웠다.
##### <u> 시간이 흐름에 따라 트럭이 다리를 지나간다라는 것을 표현하기 어려웠으나 좋은 경험이 되었다. </u>

1. 주어진 조건에 맞게 대기 트럭과 다리에 현재 있는 트럭을 표현할 큐 생성
2. 대기 트럭을 꺼내서 만약 다리에 올릴 수 있다면 맨 앞 트럭 제거 후 현재 트럭 삽입
3. 대기 트럭을 꺼내서 만약 다리에 올릴 수 없다면 0을 삽입해줌
4. 맨 마지막 트럭은 그냥 보내면 되므로 현재 정답 + 다리의 길이를 더해줌

- 6.백준(11403) 경로 찾기
####  방향 그래프에서 정점간에 관계를 파악하는 문제이다 플로이드 워셜 또는 BFS로 해결이 가능하다.
##### <u> sort를 정의함에 있어서 종료시간이 같을 때 정렬기준을 else if로 하면 segment falut에러가 뜬다.. </u>
  
1. 주어진 조건에 맞게 구조체를 선언
2. 반복문을 둘면서 구조체 벡터에 주어진 시작과 종료시간을 삽입
3. 종료시간을 기준으로 정렬 -> 종료시간이 같다면 시작시간을 기준으로 정렬
4. 반복문을 통해서 제일 빠른 순서부터 내려오면 된다.

- 7.백준(7562) 나이트의 이동
####  가중치가 없는 그래프에서의 최단거리 알고리즘인 BFS를 이용하여 해결하는 문제이다.
##### <u> Call by value로 하면 메모리 초과가 나는 문제이다  </u>
  
1. 주어진 조건에 맞게 Vector 생성
2. 시작점을 체크한 후 BFS탐색
3. TargetPoint 탐색 완료시 종료