## 중간고사

### **뮤텍스(상호배제)**

**내가 어떤 자원을 쓴다고 하면 다른쪽에서 접근을 막는 것(lock,unlock)**

- X,Y를 보호하는 뮤텍스 MX를 생성
- 스레드는 X,Y를 건드리기 전에 MX에 “사용권을 얻겠다.”라고 요청
- 스레드는 X,Y를 액세스
- 액세스가 끝나면 MX에 “사용권을 놓겠다.”라고 요청

### **교착상태**

- 상대편을 영원히 기다리는 현상 발생

### **전송 속도와 전송 지연 시간**

- 전송 속도
    - 두 기기 간에 **초당 전송될 수 있는 최대 데이터양**
    - 초당 비트수 혹은 바이트 수로 표현
- 레이턴시
    - 두 기기 간에 데이터를 **최소량 전송할 때 걸리는 시간**을 의미
    - **레이턴시에 영향을 주는 것**
        - **매체의 종류와 품질**
        - **송신자-수신자 사이의 라우터 처리 속도**
        - 송신자와 수신자 간 **네트워크 기기 안 하드웨어와 소프트웨어의 처리 속도**도 네트워크 레이턴시의 원인
    
    | 전송속도 | 패킷 유실률 | 레이턴시 |
    | --- | --- | --- |
    | 높을 수록 좋다 | 낮을 수록 좋다 | 낮을 수록 좋다 |
    | 전송될 수 있는 데이터의 단위 시간당 총량 | 전송되는 데이터가 중간에 버려지는 비율 | 전송되는 데이터가 목적지에 도착하는데 걸리는 시간 |
    | 회선의 종류가 좋을수록,네트워크 장비의 처리 속도가 빠를수록 향상 | 회선 품질이 좋을수록, 경로에 있는 라우터 개수가 적을수록, 라우터의 처리 성능이 좋을수록 좋다. | 회선 길이가 길수록, 경로에 라우터개수가 많을수록, 라우터의 처리 성능이 나쁠수록 높다. |

### **UDP / TCP 네트워킹**

- UDP 네트워킹
    - User Datagram Protocol의 약어로, 사용자가 정의한 데이터그램을 상대방에게 보낼 수 있게 하는 통신 규약(프로토콜)
    - **신뢰성보다 데이터의 빠른처리를 위해 사용**
- TCP 네트워킹
    - Transmission Control Protocool : 전송 제어 프토콜로 보내는 쪽 데이터가 받는 쪽에서 **완전히 동일함을 보장**해 주는 프로토콜로 연결 지향형이다.

| UDP  | TCP  |
| --- | --- |
| 메시지 성질을 가진다. | 일대일만 가능 |
| 데이터 일부가 뭉치거나 쪼개지지 않는다. | 데이터 일부가 뭉치거나 쪼갤 수 있음. |
| 패킷 유실 현상이 발생할 수 있다. | 지연 시간이 발생함 |
| 유실이나 순서 뒤바뀜 혹은 중복 수신이 괜찮은 경우 사용ex) 캐릭터 이동, 기관총 난사, 음성,화상 데이터 | UDP 경우를 제외하고는 TCP사용
ex) 아이템의 거래  |
| 네트워크 기기의 레이턴시 | 네트워크 기기의 레이턴시 + (100%-패킷 유실) * 재전송 대기시간 |

### 품질 확장성

- 서버를 얼마나 많이 설치할 수 있느냐
- 게임 사용자 측면에서 사용자주가 늘어나더라도 서비스 품질이 떨어지지 않고 유지
- 수직적 확장과 수평적 확장이 존재
    
    
    | 구분 | 수직적 확장 | 수평적 확장 |
    | --- | --- | --- |
    | 종류  | 부품 업그레이드
    CPU,RAM을 증설 | 서버 머신의 개수 증설 |
    | 소프트웨어 설계 비용 | 낮다 | 높다. |
    | 확장 비용 | 높다(기하급수적) | 낮다(선형적으로 높아짐) |
    | 과부하 지점 | 컴퓨터 자체 | 네트워크 장치 |
    | 오류 가능성 | 낮다(로컬 머신 안에서 동기 프로그래밍 방식이므로) | 높다(여러 머신이 비동기 프로그래밍 방식) |
    | 단위 처리 속도 | 높다(로컬 컴퓨터와 CPU와 RAM만 사용) | 낮다(여러 컴퓨터의 매시징이 오가면서 처리) |
    | 처리 가능 총량 | 낮다(컴퓨터 한 대의 성능만 사용) | 높다(여러 컴퓨터 부하가 분산) |

### **게임서버의 성능을 높이는 법**

- **단위 처리 속도 높이기**
    - 프로그램이 더 빠르게 실행할 수 있게 코드 최적화나 알고리즘 최적화
    - RPG게임에서는 길찾기 알고리즘 처리 시간을 개선하고자 path table테크닉 사용
- **서버의 과부하 영역을 분산**
    - 처리 시간을 많이 차지는 함수를 찾아 집중하여 성능 개선을 하는 **코드 프로필링 사용**
    - 처리 속도를 높일 수 없고 빈도를 낮출 수 없다면 **분산 필요**
- **네트워크 전송 시간 줄이기**
    - 양자화를 통해 메시지를 줄이거나 압축
    - 고품질 네트워크 회선을 가진 데이터센터에 서버를 설치
    - 지리적으로 가까운 데이터센터에 서버들을 분산해서 설치
- **서버를 거치지 않고 클라이언트끼리 직접 통신**
    - P2P(peer-to-peer) 네트워킹 : 클라이언트끼리 직접 메시지 송수신
    - P2P 네트워킹은 서버에 걸리는 부담도 줄여줌 **클라이언트끼리 주고 받는 데이터의 양이 클 때 더욱 효과**

### **일단 보여주고 나중에 추가**

| 레이턴시가 없을 때 | 레이턴시가 높을 때(심리적으로 더 좋아함) |
| --- | --- |
| 캐릭터가 공격을 할 때 이펙트가 동시에 발생 | 캐릭터는 그저 공격 모션만 취할 뿐 이펙트가 발생하지 않고 잠시 후에 연출 이펙트 발생 |

### **가시 영역 필터링**

- 서버가 가진 월드 전체 상태중에서 변화 하는 것 **모두 보여줄 필요 없음**
- **플레이어의 가시 영역에 있는 것들만 보내도 된다.**
    
    
    | 클라이언트가 가지고 있어야 할 정보 | 서버가 가지고 있어야 할 정보 |
    | --- | --- |
    | 자기 근처에 있는 다른 캐릭터들 정보 | 1. 플레이어 각각에 대해서 각 플레이어가 볼 수 있는 캐릭터 목록 |
    |  | 2. 캐릭터 각각에 대해서 자기 자신을 볼 수 있는 플레이어 목록 |

### **락스텝**

- 같은 상태에 같은 입력을 주면 같은 결과가 나온다는 원리
    - ex) 스타크래프트 마린 전체 이동
- 플레이어의 입력 명령에 따라 **모든 클라이언트가 동시에 씬 업데이트** 진행
- 입력 명령은 통신량이 상대적으로 매우 적다.
- 컴퓨터간 통신 레이턴시가 거의 없을 때야 완벽하게 작동된다.
    - **입력명령을 보내되 언제 실행해야 하는지에 대한 미래 시간을 같이 전송**

### **레이턴시를 줄이는 법**

- TCP 대신 UDP 사용
- 가급적 적은 수의 패킷을 전송
- 서버 간 통신과 클라이언트끼리 통신과직접 통신(P2P)도 같이 사용

### **응집도**

- 특정 영역 안에 얼마나 많은 데이터가 뭉쳐 있는지 의미
- 어떤 데이터가 있을 때 그 데이터와 자주 상관되는다른 데이터가 얼마나 많은지 의미
- 응집도가 높은 곳에는 성능 ↑
    - 비슷한 서버를 같이 두는것이 좋다.
- 응집도를 무시한 극단적인 사례
    - 좁은 지역에 몬스터가 응집
    - 전체 스킬을 쓰는 플레이어

### **데이터베이스 이중화**

| 수평 파티셔닝(레코드)  | 수직 파티셔닝(필드) |
| --- | --- |
| 더 많은 사용자를 처리하고자 갖고 있는 레코드를 서로 다른 데이터베이스 나누어 놓는다. | 한 테이블을 수직적으로 잘라서 ,다른 테이블로 나누어 놓고 그것을 다른 데이터베이스 서버에 둔다.  |

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f7e2f2ea-c2b3-435c-88be-5cdb4d88dcfc/Untitled.png)

- 같은 내용의 레코드를 서버 두 대 이상에 저장.
- 이렇게 하면 불필요한 자원 낭비로 보일 수 있지만, 그 대가로 고가용성 확보
- 특히 **데이터베이스는** 게임 서버보다 **고가용성이 더 요구**
- 액티브-패시브와 유사하게 **마스터-슬레이브 모델** 형태 자주사용

### **로드 밸런서**

- 유저가 많아지고 기능이 많이지면 서버를 분산해야 함
- 클라이언트에서 들어오는 연결을 서로 다른 인증 서버에 분배해 주는 역할
- 분산 측면에서는 로드 밸런서는 중요

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/873455ff-326f-4636-876f-f4cea57e2afa/Untitled.png)

### 로비 서버 분산 처리 하기

- 매치메이킹만 담당하는 로비 서버는 한 대 뿐이므로 동시접속자가 계속 증가하면 결국 로비 서버가 과부하에 걸림

### **유니티 용어 정리**

|  | 유니티 | 언리얼 4 |
| --- | --- | --- |
| 게임에서 독립적인 역할을 가지는 물체 단위 | 게임 오브젝트 | 엑터 |
| 물체들을 관리하는 영역 | 계층 뷰 | 씬 아웃라이너 |
| 게임에서 쓰이는 데이터 | 에셋 | 에셋 |
| 에셋들을 관리하는 영역 | 프레젝트 뷰 | 컨텐츠 브라우저 |
| 물체를 에셋화시킨 데이터 | 프리팹 | 블루프린트 |
| 물체에 추가로 탈부착하는 기능 모듈 | 컴포넌트 | 컴포넌트 |

### **씬**

- 유니티에서 씬은 하나의 게임 월드를 뜻한다.
- 씬 창에서는 씬에 존재하는 게임 오브젝트를 시각적으로 편집할 수 있음.

- 핸드
    - 씬 카메라를 움직임
- 평행이동
    - 오브젝트를 이동
    - 빨간색 : X축(오른쪽이 +방향)
    - 초록색 : Y축(위쪽이 +방향)
    - 파란색 : Z축(앞쪽이 +방향)
- 회전
    - 오브젝트를 회전
    - 빨간색 : X축(앞뒤로 고개를 숙이고 젖히는 회전)
    - 초록색 : Y축(제자리에서 팽이처럼 도는 회전)
    - 파란색 : Z축(오뚝이처럼 좌우로 기울어지는 회전)
- 스케일
    - 오브젝트 크기 조정
- 트랜스폼
    - 평행이동,회전,스케일 툴을 하나로 합친 툴
- 렉트
    - UI와 2D 오브젝트의 크기를 조정
    - 물체의 가로와 세로를 2D 직사각형으로 편집
- 씬 기모즈 : 나침반
    - 중앙 큐브 모양(투영 전환 버튼)
        - 투영을 원근 또는 등각으로 전환 가능

### **하이어라키**

- 하이어라키(계층) 창은 현재 씬에 존재하는 모든 게임 오브젝트를 나열함
    
    ![스크린샷 2022-10-23 오후 2.37.04.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5e6fa202-2f07-40ea-99a7-6fb2cb2f1327/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.37.04.png)
    

### **인스펙터**

- 인스펙터 창은 현재 선택한 게임 오브젝트의 정보를 표시함
    - 트랜스폼
        - 오브젝트의 3차원 좌표와 크기, 회전을 지정
    - 메시 필터
        - 3D 메시 파일을 받아 **오브젝트의 외곽선**을 지정
    - 메시 렌더러
        - 메시를 따라 **색을 채워 그래픽 외형**을 그림
    - 박스 콜라이더
        - 다른 물체가 부딪칠 수 있는 **물리적인 표면을 생성**

![스크린샷 2022-10-23 오후 2.37.35.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5eecdf97-619a-4de4-8555-85f8a8387316/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.37.35.png)

### **프로젝트 창**

- 프로젝트 창은 프로젝트에서 사용할 모든 에셋을 표시함.

![스크린샷 2022-10-23 오후 2.39.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19a0552c-06ca-41a7-abfc-dc7a695f8523/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.39.22.png)

### **콘솔 창**

- 콘솔 창은 유니티가 기록(로그)을 남겨 개발자에게 정보를 전달하는 곳
- 로그의 종류
    - 일반 로그(회색) : 일반적인 기록
    - 경고 로그(노란색) : 권장할 만한 수정사항이 존재할 때
    - 에러 로그(빨간색) : 잘못된 문법이나 접근 등으로 명령 실행 불가.
- 로그 출력 설정 버튼
    - Clear : 모든 로그를 지운다. 해결되지 않은 에러 로그는 제외
    - Collapse: 같은 내용의 로그끼리 묶음
    - Claer on Play : 씬을 플레이할 때 직전까지 쌓여 있던 모든 로그를 삭제
    - Clear on Build : 빌드 시 직전까지 쌓여 있던 모든 로그를 삭제
    - Error Pause : 플레이 도중 에러가 발생하면 씬을 일시 정지
    - Editor : 유니티 에디터 외부의 기기에서 원격 로그를 받음

![스크린샷 2022-10-23 오후 2.40.15.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/02b7e37d-6a1c-48b3-8d07-17f94168994b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.40.15.png)

### **Pivot**

- UI요소 내부의 기준점을 정한다.
- 피봇은 자기자신의 (0,0)을 어디에 위치시킬것인가를 결정하는 역할
- **2개의 오브젝트가 있을 때 마지막에 선택한 object를 기준**

### **Center**

- **2개의 오브젝트의 가운데를 기준**

### **전역 공간**

- 실제 선택한 오브젝트에 대한 좌표계는 무시한체로 글로벌 좌표계를 기준
- **글로벌 좌표계는 게임세상의 절대 좌표를 사용**

### **지역 공간**

- **선택한 오브젝트를 기준으로 한 좌표계**

### **C# 스크립트 구성**

- 네임스페이스,클래스 이름, 상위 클래스, 함수 등이 기본 설정

### **클래스**

| 멤버 | 설명 | 작성법 |
| --- | --- | --- |
| 생성자 | 클래스를 초기화 할 때 | Test(){…} |
| 소멸자 | 클래스를 해제할 때 | ~Test(){…} |
| 상수 | 상수 | const string Fix = “fix”; |
| 필드 | 변수 | int feild; |
| 메서드 | 메서드 | void method(){…} |
| 프로퍼티 | 클래스 밖에서는 변수처럼, 클래스 안에서는 메서드처럼 사용 | int Property{get; set;} |
| 이벤트 | 프로퍼티처럼 사용할 수 있는 메서드 | event EventHandelr Event; |
| 인덱서 | 프로퍼티처럼 사용할 수 있는 배열 | int this(int i){…} |
| 연산자 | 오버로드된 연산자 | static Test operator +(Test x, Test y){…} |
| 중첩된 형 | 클래스 내에 선언된 클래스 등 | class Test2{…} |

### **인스턴스**

- 객체

### **다른 클래스에서 멤버로 접근 가능 여부**

| 접근제한자 | 설명 |
| --- | --- |
| public | 자유롭게 접근 가능 |
| protected | 해당 클래스와 그 클래스를 상속한 클래스만 가능 |
| Intenal | 해당 어셈블리에서만 접근 |
| protected internal | 해당 어셈블리나 그 클래스를 상속한 클래스만 접근 가능 |
| internal protected | 위와 동일 |
| private | 해당 클래스 내부에서만 접근할 수 있다. |

### **추상클래스**

- 클래스 자체로는 인스턴스 생성이 불가능하고 자식 클래스로만 인스턴스 생성 가능
- 추상 클래스를 상속한 클래스에서 정의하는 메서드 : 추상 메서드
    - 추상 메서드는 선언만 한다 (정의는 상속된 클래스에서 한다)
    - 상속된 클래스에서 해당 메서드를 오버라이드

```csharp

// 추상 클래스 예시
abstract public class Person{} //추상 클래스
public class Girl : Person{} // 추상 클래스의 자식 클래스

//Person p1 = new Person(); // 추상 클래스는 인스턴스 생성 불가능
Girl p2 = new Girl(); //추상 클래스를 상속한 클래스로 인스턴스 생성 가능

// 추상 메서드 예시
abstract public class Person{ //추상 메서드는 추상 클래스에서만 선언
	abstract public void Speack(); // 선언만 하고 정의는 상속 클래스에서
}

public class Girl : Person{
	override public void Speack() {...} // 해당 메서드 오버라이드 
}
```

### **인터페이스**

- 추상 메서드만을 포함한 클래스, 처리는 구현하지 않는다.
- 인터페이스의 멤버는 접근 제한자를 붙이지 않는다.
    - 정의 하지 않고 선언만 한다.

```csharp
interface IPerson{
	void Speack();   //접근 제한자 없이 선언만 한다
} 
public class Gire : IPersion{
	public void Speack() {} //반드시 정의가 필요
}

```

### **제네릭**

- 다양한 형을 지정해도 같은 처리를 실행하고 싶을 때 사용

```csharp
public void Swap<T>(ref T x, ref T y){
	var t = x; y = x; x= t;	
}
```

### **컬렉션**

| 클래스 | 설명 |
| --- | --- |
| Dictionary(Key,Value) | 키와 값으로 구성된 컬렉션을 표현 |
| HashSet() | 값의 집합을 표현 |
| LinkedList() | 양방향 연결리스트를 표현 |
| List() | 인덱스로 접근 가능한 리스트 표현 |
| Queue() | FIFO 컬렉션을 표현 |
| Stack() | LIFO 컬렉션을 표현 |

### **상속과 재사용**

- 상속에만 의존하면 오히려 **기존 코드를 재사용하기 힘든 경우** 발생
- 부모 클래스에는 자식 클래스에 공통적으로 필요한 기능 구현
- 부모 클래스의 기존 기능이 나중에 구현한 자식 클래스의 기능과 오히려 충돌 가능
- 이러한 문제를 해결하려면 **컴포넌트 패턴**을 사용

### **컴포넌트 이해**

- 미리 만들어진 컴포넌트를 빈 껍데기인 게임 오브젝트에 조립하는 방식
    
    ![스크린샷 2022-10-23 오후 3.34.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9cf98f4b-d57d-4082-9932-fe00c13d74b3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.34.44.png)
    

### **컴포넌트 3가지 장점**

- 재사용 가능
    - 원하는 기능을 가진 컴포넌트만 선택적으로 사용 가능
- 프로그래머 의존도 감소
    - 기획자는 미리 만들어진 컴포넌트를 조립하여 게임 오브젝트 생성 가능
- 독립성
    - 어떤 기능을 추가하거나 삭제할 때 다른 기능이 망가지지 않음

### **브로드캐스팅**

- 컴포넌트 구조에서는 ‘전체 방송’을 이용해 컴포넌트의 특정 기능을 간접적으로 실행
- monoBehaviour 이해 필요

### **메시지 기반 방식**

- 컴포넌트 패턴에서 컴포넌트들을 **서로 관심이 없음**
- 유니티는 컴포넌트의 어떤 기능을 실행시키고 싶을 때 메시지를 날리는 방식을 사용
    - 메시지를 보내는 쪽은 누가 받게 될지 신경 X
    - 메시지를 받은 쪽은 누가 보냈는지 신경 X
    - 메시지를 받았을 때 메시지에 **명시된 기능을 가지고 있다면 실행 없다면 무시**

### **유니티 이벤트 메서드**

- 메시지와 브로드캐스팅은 앞으로 많이 사용할 Start(), Update(), onTriggerEnter()등의 유니티 이벤트 메서드가 동작하는 원리
- 이름 철자만 똑같이 구현해두면 메시지에 의해 자동으로 실행되는 메서드로 구성
- 클라섬 참조 링크
    - Update : frame 마다 호출,
    - Fixedupdate는 설정값에따라 호출
    - Lateupdate는 update후에 호출
    Update( )는 매 프레임마다 호출되는 함수이므로 초당 25~60회 정도 호출된다.
    예를 들어 초당 50 프레임 (50fps)가 나온다고 가정하면 매 프레임은 0.02초마다 갱신된다는 의미인데요.
    Update( ) 함수가 매 0.02초 마다 실행된다고 보시면 되겠습니다.

### **Vector 클래스**

- Vector 클래스를 가속도, 힘, 이동 속도 등 물리 수치로 사용 가능

### 오브젝트

### **플레이어 이동 - 라이프사이클 함수**

- 유니티 객체의 생애주기
    - Start : 태어남
    - Updae : 살다가
    - OnDestroy : 죽다

|  | 태어남 | 살다가 | 죽음 |
| --- | --- | --- | --- |
| 발생 횟수 | 1 | 계속 | 1 |
| 발생 일시 확인 여부 | 0 | 0 | X |
| 유니티 함수 | Start | Updae | OnDestroy |
- 기본적으로 3개의 함수를 쓸 수 있어야 함

### [**Time.delta](http://Time.delta) time**

- 기기의 성능에 따라 게임의 **갱신빈도가 다름**
- **기기별 성능의 차이를 메워주는 것**
    - 서로 다른 프레임을 가진 유저들
- 초당 이동 거리와 회전량 지정

|  | 빠른기기 | 느린기기 |
| --- | --- | --- |
| 1회 이동거리 | 낮음 | 높음 |
| 갱신빈도 | 높음 | 낮음 |

![스크린샷 2022-10-23 오후 3.49.15 작게.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/34d15c3b-2891-4600-a84a-eb1e33d2aaed/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.49.15_%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%80%E1%85%A6.jpeg)

### **Transform 과 Translate**

- Position : 방향성 없음
    - 순간적으로 워프, 어느쪽으로 향하든 관계가 없다.
- Translate : 방향성 있음
    - 지금 있는 장소에서 지정한 방향으로 지정한 거리만큼 움직인다.

![스크린샷 2022-10-23 오후 3.51.05.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a55adb6-062c-49b7-ae9c-a5c886df4537/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.51.05.png)

### **부모 클래스와 상속**

- 오브젝트는 서로의 부모-자식 관계가 될 수 있음
- 게임 조작에 편리성 제공
    - 드래그앤 드롭
    - 속성의 값을 지정
    - 자세히 봐야함

### **Vector3**

![스크린샷 2022-10-24 오후 3.11.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4c4d09e3-c06f-4ecd-8bf5-d45a59ed3fc1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.11.58.png)

### **세이더**

- 3D 모델링을 화면에 그리기 위한 조건
- Mesh(껍데기) + Material(재질)
- 재질을 표현하기 위한 정보
- 클라썸 링크 참조

### **메터리얼과 세이더의 구조**

- 메테리얼
    - 세이더와 파라미터로 구성
- 세이더
    - 유니티에서 직접 코딩하여 작성
    - HLSL,. cg 라는 C#과는 다른 언어로 작성
- 파라미터
    - 세이더에서 지정한 계산을 위해 필요로한 정보
    - 텍스쳐나 컬러, 숫자, 위치(벡터)등

![스크린샷 2022-10-23 오후 3.54.21.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fb29ca9-0f28-462d-9be3-b49113266fb2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-10-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.54.21.png)

### **Diffuse 와 Specular**

- Diffuse : 표먼의 컬러를 지징하는 용어 (Albedo와 유사)
- Specular : 물체의 정반사되는 정도를 나타내는 용어 (Smoothness와 유사)

### **Metallic(메탈릭)**

- 현실에서 입자를 잘게 쪼개보면 크게 **금속성분과 비금속 성분**으로 나눌 수 있음
- 이러한 구분을 Metallic이라는 파라미터를 통해서 제어
    - **금속**
        - 빛을 반사 시킬 때 **물체의 컬러**를 더 많이 밚사
    - **비금속**
        - 빛을 반사 시킬 때 **조명의 컬러**를 더 많이 반사

### **파티클**

- **일반 게임 오브젝트**는 삭제하라는 명령을 내리지 않으면 **종료 까지 존재**
- **파티클**은 정해지 시간이 지나면 **자동으로 삭제**
    - 파티클 시스템  ⇒ 공장
    - 파티클 ⇒ 공장에서 생상된 유통기한을 가진 신선 식품
- **파티클 시스템의 개념 : 이펙트 효과**